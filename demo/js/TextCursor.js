// Generated by CoffeeScript 1.8.0

/*
Poe.TextCursor is the visible caret on the screen. It is where all of the magic
happens when it comes to user input. It listens for keydown event from the body element
and inserts the text typed before the cursor. It also handles word wrap and page wrap.

The cursor is actually handled in two different areas. There is a span and a visible
cursor, this.element and this.visibleCursor respectively. The span is actually the
cursor that is used. It has one child that is a zero width space &#8203; When the cursor
is moved the visible cursor gets updated to the position of that span. Making it look
like it is the cursor.
 */

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Poe.TextCursor = (function() {

    /*
    Creates a Poe.TextCursor instance
    @param [Poe.Word] inside the word to put the cursor inside
     */
    function TextCursor(inside) {
      this.blink = __bind(this.blink, this);
      this.paragraphStyleChanged = __bind(this.paragraphStyleChanged, this);
      this.keyEvent = __bind(this.keyEvent, this);
      if (!inside) {
        throw new Error('Poe.TextCursor constructor expects one argument of type Poe.Word');
      }
      this.element = $('<span class="textcursor">&#8203;</span>');
      this.visibleCursor = $('<div class="visiblecursor"></div>');
      this.currentWord = inside;
      this.blinkTimer = null;
      inside.prepend(this.element);
      $('body').append(this.visibleCursor);
      this.show();
      $('body').keydown(this.keyEvent);
      this.textStyle = new Poe.TextStyle(this);
      this.textStyle.applyWord(this.currentWord);
      this.paragraphStyle = new Poe.ParagraphStyle(this);
      this.paragraphStyle.apply();
      this.paragraphStyle.changed(this.paragraphStyleChanged);
      this.capsLock = false;
    }


    /*
    Convienence function for getting the cursor contiaining word's parent
    @return [Poe.TextObject] the parent
     */

    TextCursor.prototype.currentLine = function() {
      return this.currentWord.parent;
    };


    /*
    Convienence function for currentLine().parent
    @return [Poe.TextObject] currentLine().parent
     */

    TextCursor.prototype.currentParagraph = function() {
      return this.currentLine().parent;
    };


    /*
    Convenience function for currentParagraph().parent
    @return [Poe.TextObject] currentParagraph().parent
     */

    TextCursor.prototype.currentPage = function() {
      return this.currentParagraph().parent;
    };


    /*
    Gets the next text node after the cursor. This will loop through all parents up to
    the Poe.Document if neccessary. It does not change any members unless applyChanges
    is true.
    @param applyChanges [Boolean] If true the currentWord is changed by this function.
    @return [null] if no node is found
    @return [jQuery or null] the next text node found
     */

    TextCursor.prototype.next = function(applyChanges) {
      var line, next, old, page, paragraph, word, _ref;
      if (applyChanges == null) {
        applyChanges = false;
      }
      next = this.element.nextSibling();
      word = this.currentWord;
      line = word.parent;
      paragraph = line.parent;
      page = paragraph.parent;
      while (!next) {
        _ref = [word, word.next()], old = _ref[0], word = _ref[1];
        if (old.isEmpty()) {
          old.remove();
        }
        if (!word) {
          line = line.next();
          if (!line) {
            paragraph = paragraph.next();
            if (!paragraph) {
              page = page.next();
              if (!page) {
                return null;
              }
              paragraph = page.child(0);
            }
            line = paragraph.child(0);
          }
          word = line.child(0);
        }
        next = word.children().first();
      }
      if (applyChanges && next) {
        this.currentWord = word;
      }
      if (this.currentWord !== word) {
        this.textStyle.update(word);
      }
      return next;
    };


    /*
    Gets the previous text node before the cursor. This will loop through all parents up to
    the Poe.Document containing the cursor if neccessary. This does not change any members
    unless applyChanges is true.
    @param applyChanges [Boolean] Sets the current word on return to the word containing
    the return value.
    @return [null] if no node is found
    @return [jQuery or null] the previous text node found
     */

    TextCursor.prototype.prev = function(applyChanges) {
      var line, old, page, paragraph, prev, word, _ref;
      if (applyChanges == null) {
        applyChanges = false;
      }
      prev = this.element.prevSibling();
      word = this.currentWord;
      line = word.parent;
      paragraph = line.parent;
      page = paragraph.parent;
      while (!prev) {
        _ref = [word, word.prev()], old = _ref[0], word = _ref[1];
        if (old.isEmpty()) {
          old.remove();
        }
        if (!word) {
          line = line.prev();
          if (!line) {
            paragraph = paragraph.prev();
            if (!paragraph) {
              page = page.prev();
              if (!page) {
                return null;
              }
              paragraph = page.children.last();
            }
            line = paragraph.children.last();
          }
          word = line.children.last();
        }
        if (word.children().length > 0) {
          prev = word.children().last();
        }
      }
      if (applyChanges && prev) {
        this.currentWord = word;
      }
      if (this.currentWord !== word) {
        this.textStyle.update(word);
      }
      return prev;
    };


    /*
    Moves the cursor before the previous text node found by prev()
    @return [Poe.TextCursor] this
     */

    TextCursor.prototype.moveLeft = function() {
      var prev;
      prev = this.prev(true);
      if (prev) {
        prev.before(this.element);
      }
      return this;
    };


    /*
    Moves the cursor after the next text node found by next()
    @return [Poe.TextCursor] this
     */

    TextCursor.prototype.moveRight = function() {
      var next;
      next = this.next(true);
      if (next) {
        next.after(this.element);
      }
      return this;
    };


    /*
    Moves the actual blinking cursor to where it should be.
    @return [Poe.TextCursor] this
    @private
     */

    TextCursor.prototype.update = function() {
      this.visibleCursor.css('top', "" + (this.element.position().top) + "px");
      this.visibleCursor.css('left', "" + (this.element.position().left) + "px");
      return this;
    };


    /*
    Fixes word wrap. Starts off by calling {Poe.TextCursor#paragraphStyleChanged} then
    loops through all lines of the currentParagraph() and checks to see if the
    last word in that line is outside of the editable area. If the word is
    outside it gets moved down to the next line. If no line exists a line is created
    after it.
    @return [Poe.TextCursor] this
    @private
     */

    TextCursor.prototype.doWordWrap = function() {
      var child, childWidth, hasRoom, line, newLine, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.currentParagraph().children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (line.isEmpty()) {
          line.remove();
          continue;
        }
        while (!line.visiblyContains(line.children.last())) {
          if (!line.next()) {
            newLine = new Poe.Line();
            newLine.element.attr('class', line.element.attr('class'));
            newLine.child(0).remove();
            newLine.insertAfter(line);
          } else {
            newLine = line.next();
          }
          newLine.prepend(line.children.last());
        }
        childWidth = 0;
        _ref1 = line.children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          childWidth += child.element.width();
        }
        if (!line.next()) {
          break;
        }
        if (line.next() instanceof Poe.ListItem) {
          break;
        }
        hasRoom = true;
        while (hasRoom) {
          child = line.next().child(0);
          if (!child) {
            break;
          }
          if (childWidth + child.element.width() < line.element.outerWidth(false)) {
            hasRoom = true;
            child.insertAfter(line.children.last());
          } else {
            hasRoom = false;
          }
        }
      }
      return this;
    };


    /*
    Handles typing. At first it stops the cursor from blinking. Then does anything
    neccessary to translate the keydown onto the screen. Lastly it makes the cursor
    continue blinking.
    @private
     */

    TextCursor.prototype.keyEvent = function(event) {
      var letter, li, line, next, paragraph, prev, prev2, word;
      if (event.ctrlKey) {
        return;
      }
      event.preventDefault();
      this.hide();
      switch (event.keyCode) {
        case Poe.key.Shift:
          break;
        case Poe.key.CapsLock:
          this.capsLock = !this.capsLock;
          break;
        case Poe.key.Left:
          if (this.currentWord.children().length === 1) {
            this.element.before("&#8203;");
          }
          this.moveLeft();
          break;
        case Poe.key.Right:
          this.moveRight();
          break;
        case Poe.key.Enter:
          if (this.currentParagraph() instanceof Poe.List) {
            li = new Poe.ListItem();
            li.insertAfter(this.currentLine());
            this.moveInside(li.child(0));
            this.textStyle.applyWord();
            break;
          }
          paragraph = new Poe.Paragraph();
          paragraph.insertAfter(this.currentParagraph());
          line = paragraph.child(0);
          word = line.child(0);
          this.textStyle.applyWord(word);
          while (this.element.nextSibling()) {
            word.element.append(this.element.nextSibling());
          }
          while (this.currentWord.next()) {
            line.append(this.currentWord.next());
          }
          while (this.currentLine().next()) {
            paragraph.append(this.currentLine().next());
          }
          if (this.currentWord.children().length === 1 && this.currentLine().children.length === 1) {
            this.currentWord.element.append('&#8203;');
          }
          console.log(line.children.length);
          this.currentWord = word;
          this.currentWord.element.prepend(this.element);
          this.textStyle.apply(this.currentWord);
          this.paragraphStyle.update(this.currentLine());
          break;
        case Poe.key.Backspace:
          if (this.currentPage().isEmpty() && this.currentPage().index() === 0) {
            break;
          }
          prev = this.prev();
          if (this.currentParagraph() instanceof Poe.List) {
            if (this.currentLine().index() === this.currentParagraph().children.length - 1) {
              if (this.currentWord.children().length === 1) {
                li = this.currentLine();
                paragraph = new Poe.Paragraph();
                paragraph.insertAfter(this.currentParagraph());
                this.moveInside(paragraph.child(0).child(0));
                this.textStyle.applyWord();
                if (li.parent.isEmpty()) {
                  li.parent.remove();
                } else {
                  li.remove();
                }
                break;
              }
            }
          }
          if (this.currentWord.index() === 0) {
            word = this.currentWord;
            if (this.currentWord.children().length !== 1) {
              if (prev) {
                prev.before(this.element);
              }
              if (prev) {
                prev.remove();
              }
            }
            console.log(this.currentLine().index());
            console.log(this.element.prevSibling());
            if (this.currentLine().index() !== 0 && !this.element.prevSibling()) {
              prev2 = this.currentLine().prev().children.last();
              if (this.currentLine().isEmpty()) {
                this.currentLine().remove();
              }
              if (prev2) {
                this.currentWord = prev2;
                this.currentWord.append(this.element);
              }
              break;
            } else if (this.currentLine().index() === 0 && !this.element.prevSibling()) {
              if (this.currentParagraph().index() === 0 && this.currentPage().index() === 0) {
                break;
              }
              prev2 = this.currentParagraph().prev().children.last().children.last();
              if (prev2) {
                this.currentWord = prev2;
                this.currentWord.append(this.element);
              }
              if (word.parent.parent.isEmpty()) {
                word.parent.parent.remove();
              }
              break;
            }
          }
          if (prev) {
            prev.remove();
          }
          if (!this.element.prevSibling()) {
            prev2 = this.prev();
            if (prev2) {
              prev2.after(this.element);
            }
            word = this.currentWord.prev();
            if (this.currentWord.isEmpty()) {
              this.currentWord.remove();
              this.currentWord = word;
            }
          }
          this.doWordWrap();
          break;
        case Poe.key.Delete:
          next = this.next();
          if (next) {
            next.remove();
          }
          break;
        case Poe.key.Space:
          this.element.before(" ");
          word = new Poe.Word();
          word.insertAfter(this.currentWord);
          next = this.element.nextSibling();
          while (next) {
            word.append(next);
            next = next.nextSibling();
          }
          word.prepend(this.element);
          this.currentWord = word;
          this.textStyle.applyWord(this.currentWord);
          this.doWordWrap();
          break;
        default:
          if (event.shiftKey && this.capsLock) {
            event.shiftKey = false;
          } else if (!event.shiftKey && this.capsLock && event.keyCode >= 65 && event.keyCode <= 90) {
            event.shiftKey = true;
          }
          if (event.shiftKey) {
            letter = Poe.keyMapShift[event.keyCode];
          }
          if (!event.shiftKey) {
            letter = Poe.keyMap[event.keyCode];
          }
          this.element.before(letter);
          this.doWordWrap();
      }
      return this.show();
    };


    /*
    Callback registered with {Poe.ParagraphStyle} that will update the whole
    paragraph's alignment.
     */

    TextCursor.prototype.paragraphStyleChanged = function(style) {
      return this.show();
    };


    /*
    Moves the cursor inside and at the front of word
    @param word [Poe.Word] the word to move it inside
    @throws [Error] if the word is not a Poe.Word
    @return [Poe.TextCursor] this
     */

    TextCursor.prototype.moveInside = function(word) {
      if (!word instanceof Poe.Word) {
        throw new Error('Can only move inside a Poe.Word');
      }
      word.prepend(this.element);
      this.currentWord = word;
      this.show();
      return this;
    };


    /*
    Shows the cursor if it is hidden and sets a time to make the cursor blink if
    it is not already.
    @return [Poe.TextCursor] this
     */

    TextCursor.prototype.show = function() {
      this.update();
      this.visibleCursor.removeClass('hide');
      if (this.blinkTimer) {
        return;
      }
      this.blinkTimer = setInterval(this.blink, 700);
      return this;
    };


    /*
    Hides the cursor if it is visible and stops it from blinking.
    @return [Poe.TextCursor] this
     */

    TextCursor.prototype.hide = function() {
      clearInterval(this.blinkTimer);
      this.blinkTimer = null;
      this.visibleCursor.addClass('hide');
      return this;
    };


    /*
    Controls the actual blinking of the cursor. See show()
    @private
     */

    TextCursor.prototype.blink = function() {
      return this.visibleCursor.toggleClass('hide');
    };

    return TextCursor;

  })();

}).call(this);

//# sourceMappingURL=TextCursor.js.map
